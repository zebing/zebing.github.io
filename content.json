[{"title":"web文件上传全解","date":"2017-11-10T06:48:00.000Z","path":"2017/11/10/20171110/","text":"前语在web工程开发中，由于系统的需求，或多或少都需要用到文件上传。如图片，压缩文件等。文件上传不像普通的表单上传那样，比较简单。文件上传是一个比较复杂的过程。下面将讲解文件上传的几种方式。 1.form表单提交传统的文件上传方式，通过form表单提交来上传文件。这种方是文件上传最简单最简便的方式。但它的缺点也是最大的。form表单提交给服务器，服务器接收并处理传来的表单，然后返回一个新的网页。这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML代码往往是相同的。由于每次应用的交互都需要向服务器发送请求，应用的响应时间就依赖于服务器的响应时间。导致性能贼差。因此不推荐使用。 示例代码1234&lt;form action=\"file.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 2.ajax,formData上传通过jquery中的ajax方法上传文件，因不用刷新页面，所以不会额外影响性能。但是需要用到formData来处理表单。首先new FormData1new FormData(document.getElementById(&quot;form&quot;)) 然后通过ajax传输1234567891011var fd = new FormData(document.getElementById(\"form\")); $.ajax(&#123; type:\"post\", url:\"file.php\", data: fd, processData: false, contentType: false, success: function (data) &#123; console.log(data) &#125; &#125;); 需要注意的是 processData: false,ajax不需要对数据做处理。contentType: false,因为是由form表单构造的FormData对象，且已经声明了属性enctype=”multipart/form-data”，所以这里设置为false。 3.XMLHttpRequest, formData上传XMLHttpRequest,formData上传和ajax很相似，因为ajax就是通过XMLHttpRequest封装的，差别就是上传数据要自己发送，且不用设置header,代码如下12345678var fd = new FormData(document.getElementById(\"form\")); var xhr = new XMLHttpRequest(); xhr.addEventListener('load', function(event) &#123; console.log('发送成功'); &#125;); xhr.open('post', 'file.php', true); xhr.send(fd); 4.XMLHttpRequest, 不用formData上传XMLHttpRequest, 不用formData上传相对来说较复杂，体现在上传的文件要先通过fileReader转换为二进制字符串，还要构造出form-data格式字符串，然后再通过XMLHttpRequest发送，且发送的时候需要设置header。代码如下1234567891011121314151617181920212223242526var file = document.getElementById(\"file\");var reader = new FileReader();reader.readAsDataURL(file.files[0]);reader.addEventListener(\"load\", function () &#123; var xhr = new XMLHttpRequest(); var boundary = Math.random().toString(16).substring(2);; var data = \"\"; data += \"------\" + boundary + \"\\r\\n\"; data += 'content-disposition: form-data; ' + 'name=\"' + file.name + '\"; ' + 'filename=\"' + file.files[0].name + '\"\\r\\n'; data += 'Content-Type: ' + file.files[0].type + '\\r\\n'; data += '\\r\\n'; data += reader.result + '\\r\\n'; data += \"------\" + boundary + \"------\"; xhr.addEventListener('load', function(event) &#123; console.log('发送成功'); &#125;); xhr.open('POST', 'file.php'); xhr.setRequestHeader('Content-Type','multipart/form-data; boundary=----' + boundary); xhr.send(data);&#125;);","tags":[{"name":"javascript","slug":"javascript","permalink":"//zebingfu.cn/zebing.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"//zebingfu.cn/zebing.github.io/tags/前端/"}]},{"title":"docker","date":"2017-11-06T12:41:22.000Z","path":"2017/11/06/20171106/","text":"什么是 DockerDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 3 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 为什么要使用 Docker？作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。 持续交付和部署对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 ubuntu 16.04安装docker1.如果之前安装有老版本的Docker，需要预先卸载1$ sudo apt-get remove docker docker-engine 2.安装docker包12345$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 3.添加Docker的官方GPG密钥：1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 4.设置stable稳定的仓库(stable稳定版每季度发布一次，Edge版每月一次)1234$ sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 5.更新apt包1$ sudo apt-get update 6.安装Docker CE1$ sudo apt-get install docker-ce 至此Docker CE就安装完成了，但是国内访问Docker Hub有时会遇到问题，所以我们可以配置镜像加速器。例如：阿里云，腾讯云等。如果想省去注册账号的一系列动作，可以使用我的DaoCloud加速器。1$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://8ad7943c.m.daocloud.io 之后重启docker，就能下载部署镜像了12$ systemctl restart docker$ docker run hello-world docker 常用命令1234567891011121314151617181920212223# 拉取ubuntu最新的镜像docker pull ubuntu:latest# 列出本地所有镜像docker images# 本地镜像名为 ubuntu 的所有镜像docker images ubuntu# 本地移除一个或多个指定的镜像docker rmi# 移除本地全部镜像docker rmi `docker images -a -q`# 查看当前运行的容器docker ps# 查看全部容器docker ps -a# 查看全部容器的id和信息docker ps -a -q# 查看一个正在运行容器进程，支持 ps 命令参数docker top# 删除一个容器docker rm [容器id]# 删除所有容器docker rm `docker ps -a -q`","tags":[{"name":"docker","slug":"docker","permalink":"//zebingfu.cn/zebing.github.io/tags/docker/"}]},{"title":"linux命令","date":"2017-09-15T13:05:02.000Z","path":"2017/09/15/20170915linux/","text":"ssh1. SSH远程登 ssh username@127.0.0.12. 将文件/文件夹从远程Ubuntu机拷至本地(scp) scp -r username@192.168.0.1:/home/username/remotefile.txt /home/username３．将文件/文件夹从远程Ubuntu机拷至本地(scp)scp -r username@192.168.0.1:/home/username/remotefile.txt /home/username 常用指令ls 显示文件或目录 - l 列出文件详细信息l(list) - a 列出当前目录下所有文件及目录，包括隐藏的a(all)mkdir 创建目录 -p 创建目录，若无父目录，则创建p(parent)cd 切换目录touch 创建空文件echo 创建带有内容的文件。cat 查看文件内容cp 拷贝mv 移动或重命名rm 删除文件 -r 递归删除，可删除子目录及文件 -f 强制删除find 在文件系统中搜索某文件rmdir 删除空目录tree 树形结构显示目录，需要安装tree包ln 创建链接文件 系统管理命令stat 显示指定文件的详细信息，比ls更详细who 显示在线登陆用户whoami 显示当前操作用户hostname 显示主机名uname 显示系统信息top 动态显示当前耗费资源最多进程信息ps 显示瞬间进程状态 ps -auxifconfig 查看网络情况ping 测试网络连通netstat 显示网络状态信息clear 清屏kill 杀死进程，可以先用ps或top命令查看进程的id，然后再用kill命令杀死进程 Linux软件包管理dpkg (Debian Package)管理工具，软件包名以.deb后缀。这种方法适合系统不能联网的情况下。比如安装tree命令的安装包，先将tree.deb传到Linux系统中。再使用如下命令安装。sudo dpkg -i tree_1.5.3-1_i386.deb 安装软件sudo dpkg -r tree 卸载软件 vim使用vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。命令模式下：:q 退出:q! 强制退出:wq 保存并退出 用户及用户组管理 添加一个用户组并指定id为1002sudo groupadd －g 1002 www 添加一个用户到www组并指定id为1003sudo useradd wyx -g 1002 -u 1003 -m 修改用户的密码sudo passwd wyx 删除一个用户sudo userdel wyx 为该用户添加sudo权限sudo usermod -a -G adm wyxsudo usermod -a -G sudo wyx 查看所有用户和用户组：cat /etc/passwdcat /etc/group apt-getsudo apt-get install package 安装包sudo apt-get install package - - reinstall 重新安装包sudo apt-get -f install 修复安装”-f = ——fix-missing”sudo apt-get remove package 删除包sudo apt-get remove package - - purge 删除包，包括删除配置文件等sudo apt-get update 更新源sudo apt-get upgrade 更新已安装的包apt-cache rdepends package 是查看该包被哪些包依赖apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 其他让进程后台运行＆ 或 ctrl+z 输入bg","tags":[{"name":"linux","slug":"linux","permalink":"//zebingfu.cn/zebing.github.io/tags/linux/"}]},{"title":"javascript继承","date":"2017-07-30T13:05:02.000Z","path":"2017/07/30/20170630-javascript继承/","text":"javascript是一门面向对象的弱类型语言，继承也是它的一大特性。 原型继承要继承就要有子类和父类 1234567891011// 父类function superClass(name) &#123; this.name = name || '我是父类';&#125;superClass.prototype.getName = function() &#123; console.log(this.name);&#125;// 子类function subClass(name) &#123; superClass.call(this, name);&#125; 然后在把superClass实例赋予subClass原型 123456subClass.prototype = new superClass();subClass.constructor = subClass;var sub = new subClass('我是子类');sub.getName(); // 我是父类console.log(sub instanceof superClass); //trueconsole.log(sub instanceof subClass); //true","tags":[{"name":"javascript","slug":"javascript","permalink":"//zebingfu.cn/zebing.github.io/tags/javascript/"}]},{"title":"mysql数据库存储引擎","date":"2017-07-27T09:36:55.000Z","path":"2017/07/27/mysql-2017-07-27/","text":"存储引擎是MySQL数据库管理系统的一个重要特征，在具体开发过程中，选择对的存储引擎对系统的性能来说尤为重要。当然，对那些性能要求不高的系统除外。 在MySQL5.5版本中，共支持9种存储引擎，分别为FEDERATED、MRG_MYISAM、MYISAM、BLACKHOLE、CSV、MEMORY、ARCHIVE、InnoDB和PERFORMANCE_SCHEMA。 输入如下命令可查看所有存储引擎1$ show engines \\G 输入如下命令可查看默认存储引擎1$ show variables like 'storage_engine%' 如何选择存储引擎选择MySQL数据库管理系统存储引擎是一个非常复杂的问题。因为每个存储引擎都有各自的优势，特性和应用场景。所以要选择一个合适的存储引擎，就要掌握存储引擎的特性。 下面是几种常用的存储引擎特性比较 特性 MyISAM InnoDB MEMORY 存储限制 有 64TB 有 事物安全 不支持 支持 不支持 锁机制 表锁 行锁 表锁 B树索引 支持 支持 支持 哈希索引 不支持 不支持 支持 全文搜索 支持 不支持 不支持 集群索引 不支持 支持 不支持 数据缓存 支持 支持 索引缓存 支持 支持 支持 数据可压缩 支持 不支持 不支持 空间使用 低 高 N/A 内存使用 低 高 中等 批量插入的速度 高 低 高 支持外键 不支持 支持 不支持 MyISAM 不支持事物，不支持外键，访问速度较快。对事物完整性没有要求并以访问为主的应用适合选用 InnoDB 在事务上有优势，支持具有提交，回滚和崩溃恢复能力的事务安装，比MYISAM占用更多的磁盘空间。需要进行频繁更新，删除操作，同时对事物完整性有要求的适合选用 MEMORY 使用内存保存数据，访问速度较快。但安全上没有保障。应用中涉及数据较小，需进行快速访问适合选用","tags":[{"name":"mysql","slug":"mysql","permalink":"//zebingfu.cn/zebing.github.io/tags/mysql/"}]},{"title":"图片懒加载","date":"2017-06-15T04:41:48.000Z","path":"2017/06/15/lazy-20170615/","text":"在那些图片比较多的网站，如果一开始就全部加载出来，不仅会严重拖慢网站的性能，给用户不好的体验，还会加载那些用户不会看到的图片，浪费用户的流量。这显然，不是我们所想要的。因此，我们必须要对这些图片加载进行优化，那就是懒加载。 什么是图片懒加载？简单的说，图片懒加载就是只对那些要用到的图片进行加载，没用到的就不给它加载。 如何实现？首先我们先获取所有的img节点 1document.getElementsByTagName('img') 然后监听页面的scroll事件，页面一滑动，就加载那些需要显示的图片，另外为了不重复显示，在那些已经显示的图片，我们给它加一个属性data-load赋值true。 刚开始只加载三张图片 随着页面的滑动，渐渐的加载剩下的图片下面是完整的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;title&gt;懒加载&lt;/title&gt; &lt;style type=\"text/css\"&gt; html,body,ul&#123;margin: 0;padding: 0;&#125; li&#123;list-style: none;width: 100%;min-height: 300px;box-shadow: 0 0 10px blue;overflow: hidden;&#125; li:not(:first-child)&#123;margin: 20px 0;&#125; .container&#123;width: 300px; margin: 0 auto;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img data-src=\"./image/1.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img data-src=\"./image/2.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img data-src=\"./image/3.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img data-src=\"./image/4.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img data-src=\"./image/5.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img data-src=\"./image/6.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img data-src=\"./image/8.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img data-src=\"./image/9.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img data-src=\"./image/10.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img data-src=\"./image/11.jpg\" width=\"100%\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; function Lazy()&#123; this.img = []; this.height; //视口高度 this.beforeView = 10; //在视口之前10px加载 &#125; Lazy.prototype = &#123; //下载图片 loadImg: function() &#123; this.img = this.img.length ? this.img : document.getElementsByTagName('img'); for(var i = 0; i &lt; this.img.length; i++) &#123; if(this.isLoad(this.img[i])) &#123; if(!this.img[i].getAttribute('data-load')) &#123; this.img[i].src = this.img[i].getAttribute('data-src'); this.img[i].setAttribute('data-load', 'true') &#125; &#125;else&#123; return; &#125; &#125; &#125;, //判断是否继续下载图片 isLoad: function(ele) &#123; this.height = this.height ? this.height : (window.innerHeight || document.documentElement.clientHeight); var sh = document.body.scrollTop || document.documentElement.scrollTop; var et = ele.offsetTop; var ch = et - sh - this.beforeView; if(ch &lt;= this.height) &#123; return true; // 继续加载 &#125;else&#123; return false; //停止加载 &#125; &#125; &#125; var lazy = new Lazy(); lazy.loadImg(); window.onscroll = function () &#123; lazy.loadImg(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"//zebingfu.cn/zebing.github.io/tags/javascript/"},{"name":"懒加载","slug":"懒加载","permalink":"//zebingfu.cn/zebing.github.io/tags/懒加载/"}]},{"title":"php 自动加载","date":"2017-06-11T06:48:00.000Z","path":"2017/06/11/hp-autoload/","text":"在开发过程中，每个类通常被放在单独的一个文件，而要使用这些类，就要将类文件加载进来。以前通常用include包含进来，但是如果有很多类文件，那就要写一长串的include，令人很烦恼。 在php5之后，有了更好的解决方法。那就是自动加载。自动加载有两个方法。分别是__autoload()和spl_autoload_register()。尽管 __autoload()函数也能自动加载类和接口，但是相对spl_autoload_register() 来说不够灵活，而且以后可能被淘汰，建议使用spl_autoload_register()来自动加载。 __autoload()虽然不建议使用 __autoload() 但还是要简单说一下。下面举一个简单的使用。假设有两个类，A类和B类，分别在A.php和B.php中。A类1234567&lt;?phpclass A &#123; public function __construct() &#123; echo '我是A类&lt;br/&gt;'; &#125;&#125; B类1234567&lt;?phpclass B &#123; public function __construct() &#123; echo '我是B类&lt;br/&gt;'; &#125;&#125; 在index.php中调用A类和B类123456789101112&lt;?phpfunction __autoload($class) &#123; $file = $class . '.class.php'; if (is_file($file)) &#123; require_once($file); &#125; &#125; $a = new A();$b = new B();//我是A类//我是B类 spl_autoload_register()(PHP 5 &gt;= 5.1.2, PHP 7)spl_autoload_register — 注册给定的函数作为 __autoload 的实现 说明1bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] ) 将函数注册到SPL __autoload函数队列中。如果该队列中的函数尚未激活，则激活它们。 如果在你的程序中已经实现了__autoload()函数，它必须显式注册到__autoload()队列中。因为 spl_autoload_register()函数会将Zend Engine中的__autoload()函数取代为spl_autoload()或spl_autoload_call()。 如果需要多条 autoload 函数，spl_autoload_register() 满足了此类需求。 它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下， __autoload() 只可以定义一次。 参数autoload_function欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数spl_autoload()。 throw此参数设置了 autoload_function 无法成功注册时， spl_autoload_register()是否抛出异常。 prepend如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。 返回值成功时返回 TRUE， 或者在失败时返回 FALSE。 例子同样假设有两个类，A类和B类，分别在A.php和B.php中。A类1234567&lt;?phpclass A &#123; public function __construct() &#123; echo '我是A类&lt;br/&gt;'; &#125;&#125; B类1234567&lt;?phpclass B &#123; public function __construct() &#123; echo '我是B类&lt;br/&gt;'; &#125;&#125; 在index.php中调用A类和B类12345678&lt;?phpspl_autoload_register();$a = new A();$b = new B();//我是A类//我是B类 这只是spl_autoload_register()简单的使用，这里调用的默认的spl __autoload()方法来加载，当然我们也可以自己定义__autoload()1234567891011121314&lt;?phpfunction load($class) &#123; $file = $class . '.class.php'; if (is_file($file)) &#123; require_once($file); &#125; &#125; spl_autoload_register('load'); $a = new A();$b = new B();//我是A类//我是B类 扩展如果类文件的名字不是A.php，B.php，而是A.class.php，B.class.php,也不再同一目录下，而在class目录下，那么就会出现问题。方法1 通过set_include_path()和spl_autoload_extensions()1234567&lt;?phpset_include_path('class');spl_autoload_extensions('.class.php');spl_autoload_register(); $a = new A();$b = new B(); 方法二 通过自己定义__autoload()123456789101112&lt;?phpfunction load($class) &#123; $file = './class/'.$class . '.class.php'; if (is_file($file)) &#123; require_once($file); &#125; &#125; spl_autoload_register('load'); $a = new A();$b = new B();","tags":[{"name":"php","slug":"php","permalink":"//zebingfu.cn/zebing.github.io/tags/php/"},{"name":"自动加载","slug":"自动加载","permalink":"//zebingfu.cn/zebing.github.io/tags/自动加载/"}]},{"title":"javascript设计模式之单例模式","date":"2017-06-07T06:48:00.000Z","path":"2017/06/07/javascriptdanlimoshi/","text":"介绍单例模式的定义是保证一个类有且只有一个实例存在。 单例模式的的用途试想一下,当我们单击登录按钮的时候,页面中会出现一个登录浮窗,而这个登录浮窗是唯一的,无论单击多少次登录按钮,这个浮窗都只会被创建一次,那么这个登录浮窗就适合用单例模式来创建。比如大家都知道的12306 是唯一购票网站，所有人要网上订票都得访问这个单例。 单例模式带来的好处除了减少不必要的重复的实例创建、减少内存占用外，更重要的是避免多个实例的存在造成逻辑上的错误。比如超级马里奥的游戏中，虽然各种小怪的实例会不断创建多个，但当前的玩家肯定只有一个，如果游戏运行过程中创建出新的马里奥的实例了，显然就出 bug 了。 实现实现的方法是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。 123456789101112131415var Single = function( name )&#123; this.name = name; this.instance = null;&#125;;Single.getInstance = function( name )&#123; if ( !this.instance )&#123; this.instance = new Single( name ); &#125; return this.instance;&#125;;var obj1 = Single.getInstance( 'name1' );var obj2 = Single.getInstance( 'name2' );alert ( obj1 === obj2 );// true 扩展用代理实现单例模式1234567891011121314151617var Single = function( name )&#123; this.name = name;&#125;;var proxy = (function( name )&#123; var instance; return function(name)&#123; if ( !instance )&#123; instance = new Single( name ); &#125; return instance; &#125; &#125;)();var obj1 = proxy( 'name1' );var obj2 = proxy( 'name2' );alert ( obj1 === obj2 );// true","tags":[{"name":"javascript","slug":"javascript","permalink":"//zebingfu.cn/zebing.github.io/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"//zebingfu.cn/zebing.github.io/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"//zebingfu.cn/zebing.github.io/tags/单例模式/"}]},{"title":"nginx配置pathinfo方法","date":"2017-06-03T06:48:00.000Z","path":"2017/06/03/pathinfo/","text":"什么是pathinfo?要想在nginx下配pathinfo,首先要先搞清楚什么是pathinfo?大家都知道一般我们访问php后台文件的时候,路径一般都是http://localhost/xxx.php, 假设我们的路径是 http://localhost/xxx ,而这时如果没有配置pathinfo的话,屏幕就会显示404,就是找不到该文件或该文件不存在。在thinkphp5框架中的路径就是这种模式。有些朋友可能会问：在apache下面没有配置pathinfo怎么没有出现问题。这是因为apache已经默认配置了pathinfo。说了这么多，那究竟什么是pathinfo呢？ 首先要说明一点，pathinfo不是nginx的功能，pathinfo是php的功能。php中有两个pathinfo，一个是环境变量$_SERVER[‘PATH_INFO’]；另一个是pathinfo函数，pathinfo() 函数以数组的形式返回文件路径的信息;。nginx能做的只是对$_SERVER[‘PATH_INFO]值的设置。 nginx配置pathinfo下面是一个完整的配置1234567891011121314151617181920212223242526272829303132333435363738394041server &#123; listen 80; listen [::]:80; # listen [::]:443 ssl http2; # listen 443 ssl http2; # include ssl.conf; # ssl_certificate /path/to/crt; # ssl_certificate_key /path/to/key; root /var/www; #网站根目录 index index.html index.htm index.php; server_name localhost; #域名 location / &#123; index index.html index.htm index.php; if (!-e $request_filename) &#123; rewrite ^/(.*)$ /index.php?s=$1 last; break; &#125; &#125; location /phpmyadmin &#123; index index.php; &#125; location ~ \\.php$ &#123; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; #php7.0版本 fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $request_uri; &#125; location ~ /\\.ht &#123; deny all; &#125;&#125; 只需要修改把下面三个地方修改成对应的东西即可 root /var/www; #网站根目录 server_name localhost; #域名 fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; #php7.0版本","tags":[{"name":"php","slug":"php","permalink":"//zebingfu.cn/zebing.github.io/tags/php/"},{"name":"nginx","slug":"nginx","permalink":"//zebingfu.cn/zebing.github.io/tags/nginx/"},{"name":"thinkphp","slug":"thinkphp","permalink":"//zebingfu.cn/zebing.github.io/tags/thinkphp/"},{"name":"pathinfo","slug":"pathinfo","permalink":"//zebingfu.cn/zebing.github.io/tags/pathinfo/"}]},{"title":"ubuntu 16.04 composer的安装，卸载及使用国内镜像","date":"2017-06-01T06:48:00.000Z","path":"2017/06/01/composer/","text":"安装composer的安装比较简单，执行如下命令就可以 1$ apt-get install composer 卸载有时候composer在使用过程中产生了一些错误，或者认为操作产生的错误，影响到composer的继续使用，这是不得不卸载重装（简单粗暴但是有效）。首先卸载composer 1$ apt-get remove composer 然后把composer依赖的你不再需要的东西也删掉 1$ apt-get autoremove 使用国内镜像由于composer的源镜像是在国外，导致我们在执行composer install 的时候会出现超时，而无法安装完成，比如腾讯云或阿里云服务器，以下为出错信息 root@VM-180-14-ubuntu:/# composer installLoading composer repositories with package informationUpdating dependencies (including require-dev)Failed to decode response: zlib_decode(): data errorRetrying with degraded mode, check https://getcomposer.org/doc/articles/troubleshooting.md#degraded-mode for more info [Composer\\Downloader\\TransportException] Your configuration does not allow connection to http://packagist.org. See h ttps://getcomposer.org/doc/06-config.md#secure-http for details. install [–prefer-source] [–prefer-dist] [–dry-run] [–dev] [–no-dev] [–no-plugins] [–no-custom-installers] [–no-autoloader] [–no-scripts] [–no-progress] [-v|vv|vvv|–verbose] [-o|–optimize-autoloader] [-a|–classmap-authoritative] [–ignore-platform-reqs] [–] []… 有两种方式启用本镜像服务：系统全局配置： 即将配置信息添加到 Composer 的全局配置文件 config.json 中。见“方法一”单个项目配置： 将配置信息添加到某个项目的 composer.json 文件中。见“方法二” 方法一： 修改 composer 的全局配置文件（推荐方式） 打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令： 1composer config -g repo.packagist composer https://packagist.phpcomposer.com 方法二： 修改当前项目的 composer.json 配置文件： 打开命令行窗口（windows用户）或控制台（Linux、Mac 用户），进入你的项目的根目录（也就是 composer.json 文件所在目录），执行如下命令： 1composer config repo.packagist composer https://packagist.phpcomposer.com 上述命令将会在当前项目中的 composer.json 文件的末尾自动添加镜像的配置信息（你也可以自己手工添加）： 123456\"repositories\": &#123; \"packagist\": &#123; \"type\": \"composer\", \"url\": \"https://packagist.phpcomposer.com\" &#125;&#125;","tags":[{"name":"php","slug":"php","permalink":"//zebingfu.cn/zebing.github.io/tags/php/"},{"name":"ubuntu","slug":"ubuntu","permalink":"//zebingfu.cn/zebing.github.io/tags/ubuntu/"},{"name":"composer","slug":"composer","permalink":"//zebingfu.cn/zebing.github.io/tags/composer/"}]},{"title":"ubuntu 16.04 搭建lnmp环境","date":"2017-05-20T06:48:00.000Z","path":"2017/05/20/ubuntu-16-04/","text":"前语首先切换到root下安装 1$ sudo -i 不一定要在root下，自己视情况而定，这里我是在root下安装 安装nginx12$ apt-get update$ apt-get install nginx 首先执行 apt-get update 更新软件源，然后安装 apt-get install nginx 这时候检验一下是否搭建成功，在浏览器输入 localhost 如果浏览器显示 welcome to nginx 则说明nginx已经安装成功 安装mysql1$ apt-get install mysql-server 安装过程中会让你输入两次密码,这是root密码,一定要记下来,后面安装phpmyadmin会用到 安装php7.01$ apt-get -y install php7.0-fpm php7.0-mysql php7.0-curl 安装完之后,要改掉php配置中的 fix_pathinfo 潜在安全漏洞 1$ vim /etc/php/7.0/fpm/php.ini 找到下面这条语句 ;cgi.fix_pathinfo=1 改成 cgi.fix_pathinfo=0 然后重启php,记住修改配置文件一定要重启一下才会生效 1$ systemctl restart php7.0-fpm 下面添加nginx配置文件,以支持php 1$ vim /etc/nginx/sites-available/default 下面是要添加的内容 1234567891011121314151617181920212223242526272829303132333435server &#123; listen 80; listen [::]:80; # listen [::]:443 ssl http2; # listen 443 ssl http2; # include ssl.conf; # ssl_certificate /path/to/crt; # ssl_certificate_key /path/to/key; #server_domain_or_IP改成你的网站目录名称 root /var/www/server_domain_or_IP; index index.html index.htm index.php; #server_domain_or_IP改成你的域名或ip server_name server_domain_or_IP; location / &#123; try_files $uri $uri/ =404; &#125; location /phpmyadmin &#123; index index.php; &#125; location ~ \\.php$ &#123; include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.0-fpm.sock; &#125; location ~ /\\.ht &#123; deny all; &#125;&#125; 然后重启nginx 1$ systemctl restart nginx 接下来测试PHP是否已完成安装配置,上面nginx配置root /var/www/html; 1$ vi /var/www/html/info.php 添加以下内容 123&lt;?php phpinfo();?&gt; 在浏览器中输入 localhost/info.php 出现下图则说明安装成功 安装phpMyAdmin12$ apt-get update$ apt-get install phpmyadmin php-mbstring php-gettext 创建phpmyadmin链接 1$ ln -s /usr/share/phpmyadmin/ /var/www/html/ 重启nginx 1$ systemctl restart nginx 在浏览器重输入 localhost/phpmyadmin 出现下图则说明安装成功 注意事项 vim /etc/php/7.0/fpm/php.ini 可能会提示您没有安装vim,安装就行,安装命令 apt-get install vim vi和vim编辑文件,首先按 i 开始编辑,编辑完之后 按Esc键,然后按 shift+: 最后输入wq保存","tags":[{"name":"php","slug":"php","permalink":"//zebingfu.cn/zebing.github.io/tags/php/"},{"name":"ubuntu","slug":"ubuntu","permalink":"//zebingfu.cn/zebing.github.io/tags/ubuntu/"},{"name":"mysql","slug":"mysql","permalink":"//zebingfu.cn/zebing.github.io/tags/mysql/"},{"name":"nginx","slug":"nginx","permalink":"//zebingfu.cn/zebing.github.io/tags/nginx/"},{"name":"phpmyadmin","slug":"phpmyadmin","permalink":"//zebingfu.cn/zebing.github.io/tags/phpmyadmin/"}]},{"title":"Hello World","date":"2017-05-19T06:48:00.000Z","path":"2017/05/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]